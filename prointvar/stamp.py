#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""

This defines the methods that work with
STAMP - Structural Alignment of Proteins.

FÃ¡bio Madeira, 2017+

"""

# STAMP file types:
# blocks format
# Domain description file

import os
import logging
import pandas as pd
from io import StringIO

from prointvar.pdbx import PDBXwriter

from prointvar.library import stamp_types

from prointvar.config import config

logger = logging.getLogger("prointvar")


def parse_stamp_domain_definitions_from_from_file(inputfile):
    """
    Parses a STAMP domain definitions file.

    STAMP domain definition format:
      <file_path> <domain_id> { <residue_ranges> }
        where <residue_ranges> =>
            <CHAIN> <RES> <INSCODE> TO <CHAIN> <RES> <INSCODE>

        <INSCODE> == '_' if None

        e.g.
            1hww.pdb 1hwwA { A 648 _ TO A 927 _ }

            1hww.pdb 1hwwB { A 648 b TO A 650 _  A 655 _ TO A 927 _ }

    :param inputfile: path to input file
    :return: pandas DataFrame
    """

    lines = []
    with open(inputfile, 'r') as inlines:
        for line in inlines:
            if not line.startswith('% STAMP'):

                info = {'path': path,
                        'domain_id': domain_id,
                        'start': start,
                        'end': end,
                        'start_inscode': start_inscode,
                        'end_inscode': end_inscode}
                lines.append(info)
    return pd.DataFrame(lines)


def get_stamp_domain_line(data):
    """
    Returns a STAMP domain definition line.

    STAMP domain definition format:
      <file_path> <domain_id> { <residue_ranges> }
        where <residue_ranges> =>
            <CHAIN> <RES> <INSCODE> TO <CHAIN> <RES> <INSCODE>

        <INSCODE> == '_' if None

        e.g.
            1hww.pdb 1hwwA { A 648 _ TO A 927 _ }

            1hww.pdb 1hwwB { A 648 b TO A 650 _  A 655 _ TO A 927 _ }

    :param data: pandas DataFrame object
    :return: returns a STAMP domain-formatted line
    """

    table = data
    path = table["path"]
    domain = table["domain_id"]
    start = table["start"]
    start_inscode = table["start_inscode"]
    end = table["end"]
    end_inscode = table["end_inscode"]
    chain = table["chain_id"]

    assert type(start) is tuple
    assert type(start_inscode) is tuple
    assert type(end) is tuple
    assert type(end_inscode) is tuple

    string = []
    for i, j, k, l in zip(start, start_inscode, end, end_inscode):
        if j == " " or j == "?":
            j = "_"
        if l == " " or l == "?":
            l = "_"
        string.append("%s %s %s TO %s %s %s" % (chain, i, j, chain, k, l))
    string = "{ %s }" % (" ".join(string))
    domain_definition = " ".join([path, domain, string])

    return domain_definition


def write_stamp_domain_definitions_from_table(outputfile, data, override=False):
    """
    Generic method that writes STAMP domain definitions from a pre-formatted
    Pandas DataFrame.

    :param outputfile: path to the PDB file
    :param data: pandas DataFrame object
    :param override: boolean
    :return: (side effects) writes to file
    """

    domain_lines = ['% STAMP domains file generated by ProIntVar']
    for entry in data:
        domain_lines.append(get_stamp_domain_line(data=entry))

    # write the final output
    if not os.path.exists(outputfile) or override:
        with open(outputfile, 'w') as outlines:
            outlines.write("\n".join(domain_lines) + "\n")
    else:
        logger.info("Domain definitions for %s already available...", outputfile)
    return


def parse_stamp_scan_scores_from_file(inputfile, excluded=()):
    """
    Parse STAMP SCAN mode scores.

    :param inputfile: path to the mmCIF file
    :param excluded: option to exclude mmCIF columns
    :return: returns a pandas DataFrame
    """

    logger.info("Parsing STAMP SCAN scores from lines...")

    # example lines with some problems
    """
    (...)
         Domain1         Domain2          Fits  Sc      RMS   Len1 Len2 Align Fit   Eq. Secs    %I    %S     P(m)
    Scan 2uuar_          1ekcc_             1   4.782   1.101   73   50   65   45   36    1  41.67  77.78 6.09e-07
    Scan 2uuar_          1ekch_             1   4.684   1.091   73   50   64   44   37    1  40.54  72.97 5.41e-06
    Scan 2uuar_          1fjfr_             1   9.648   0.526   73   73   73   73   73    7  98.63  93.15 6.57e-71
    Scan 2uuar_          1fjgr_             1   9.596   0.511   73   73   73   73   73    6  98.63  90.41 6.57e-71
    Scan 2uuar_          1fkar_             1   4.028   1.082   73   50   62   39   33    1  45.45  72.73 1.56e-07
    """

    if not os.path.isfile(inputfile):
        raise IOError("{} not available or could not be read...".format(inputfile))

    # parsing atom lines
    header = ["Domain1", "Domain2", "Fits", "Sc", "RMS", "A_Len", "B_Len",
              "Align_Len", "N_Fit", "N_Equiv", "N_SS_Equiv", "PID", "SS_PID", "Pm"]
    lines = []
    with open(inputfile) as inlines:
        for line in inlines:
            if line.startswith("Scan"):
                lines.append(line.lstrip("Scan "))
    lines = "".join(lines)

    all_str = {key: str for key in header}
    table = pd.read_table(StringIO(lines), delim_whitespace=True, low_memory=False,
                          names=header, compression=None, converters=all_str,
                          keep_default_na=False)

    # excluding columns
    if excluded is not None:
        assert type(excluded) is tuple
        try:
            table = table.drop(list(excluded), axis=1)
        except ValueError:
            # most likely theses are not in there
            pass

    # enforce some specific column types
    for col in table:
        if col in stamp_types:
            try:
                table[col] = table[col].astype(stamp_types[col])
            except ValueError:
                # there are some NaNs in there
                pass

    if table.empty:
        raise ValueError('{} resulted in an empty DataFrame...'.format(inputfile))

    return table


if __name__ == '__main__':
    pass
