#!/usr/bin/env python
# -*- coding: utf-8 -*-


"""

This is where methods that handle genetic variants.

FÃ¡bio Madeira, 2017+

"""

import logging
import pandas as pd

from prointvar.library import uni_var_types

logger = logging.getLogger("prointvar")


def flatten_json(data, entries, ix=1, prefix=None):
    """
    Flattens a bunch of nested dictionaries

    :param data: "features" Dict
    :param entries: Dict
    :param ix: Count index
    :param prefix: name prefix
    :return: updates the 'entries' dictionary
    """
    for key, val in data.items():
        if type(val) not in (dict, list):
            if prefix is None:
                entries["%s_%s" % (ix, key)] = val
            else:
                entries["%s_%s_%s" % (ix, prefix, key)] = val
        else:
            if type(val) is dict:
                for j, k in enumerate(val.keys()):
                    nkey = "%s_%s_%s_%s" % (ix, prefix, key, k)
                    if type(val[k]) is dict:
                        flatten_json(val[k], entries, ix + j, prefix=nkey)
                    else:
                        entries[nkey] = val[k]

            elif type(val) is list:
                for l, v in enumerate(val):
                    flatten_json(v, entries, ix + l, prefix=key)


def collapse_unique_values(entries):
    """
    Collapses the Dictionary generated by flatten_json to
     unique columns, where columns with multiple times are
     aggregated to the same column, and the items grouped by order
     in a list

    :param entries: Dict
    :return: returns a column aggregated dictionary
        (similar to the 'unique' group_by aggregation in pandas)
    """
    unique_names = []
    for key in entries.keys():
        name = '_'.join(key.split('_')[1:])
        if name not in unique_names:
            unique_names.append(name)

    col_counts = {}
    for key in entries.keys():
        name = '_'.join(key.split('_')[1:])
        if name in unique_names:
            if name not in col_counts:
                col_counts[name] = 1
            else:
                col_counts[name] += 1

    new_entries = {}
    for key, val in entries.items():
        col = '_'.join(key.split('_')[1:])

        if col not in new_entries:
            if col_counts[col] > 1:
                new_entries[col] = [val]
            else:
                new_entries[col] = val
        else:
            new_entries[col].append(val)
    return new_entries


def flatten_uniprot_variants_ebi(data, excluded=()):
    """
    Flattens the json output obtained from the Proteins API variants
     endpoint.

    :param data: original response (json output)
    :param excluded: option to exclude VAR columns
    :return: returns a pandas DataFrame
    """

    try:
        data = data.json()
    except AttributeError:
        assert type(data) is dict

    var_rows = []
    for entry in data["features"]:
        entries = {"1_%s" % k: v for k, v in data.items() if k != "features"}

        flatten_json(entry, entries)
        var_rows.append(collapse_unique_values(entries))

    table = pd.DataFrame(var_rows)

    if excluded is not None:
        assert type(excluded) is tuple
        try:
            table = table.drop(list(excluded), axis=1)
        except ValueError:
            # most likely theses are not in there
            pass

    # enforce some specific column types
    for col in table:
        if col in uni_var_types:
            try:
                table[col] = table[col].astype(uni_var_types[col])
            except ValueError:
                # there are some NaNs in there
                pass
        else:
            print('missing', col)

    if table.empty:
        raise ValueError('Variants collapsing resulted in an empty DataFrame...')

    return table


def get_ensembl_protein_id_from_mapping(data):
    """
    Gets a list of Ensembl IDs from a 'xrefs/symbol/' mapping.

    :param data: Requests object from the Ensembl-UniProt Mapping
    :return: list of Ensembl Protein IDs
    """
    ensps = []
    for entry in data:
        if 'type' in entry and 'id' in entry:
            if entry['type'] == 'translation':
                if entry['id'] not in ensps:
                    ensps.append(entry['id'])
    return ensps


def get_uniprot_id_from_mapping(data, full_entry=False, uniprot_id=None):
    """
    Gets a list of UniProt IDs from a '"xrefs/id/"' mapping.

    :param data: Requests object from the Ensembl-UniProt Mapping
    :param full_entry: (boolean) if True gets dictionary instead of just
        the UniProt IDs
    :param uniprot_id: if not None means that we want the data for a specific
        UniProt ID
    :return: list of UniProt IDs
    """
    uniprots = []
    for entry in data:
        if 'dbname' in entry and 'primary_id' in entry:
            if uniprot_id is not None and entry['primary_id'] == uniprot_id:
                if full_entry:
                    uniprots.append(entry)
                else:
                    uniprots.append(entry['primary_id'])
            elif entry['dbname'] == 'Uniprot/SWISSPROT':
                if entry['primary_id'] not in uniprots:
                    if full_entry:
                        uniprots.append(entry)
                    else:
                        uniprots.append(entry['primary_id'])
            elif entry['dbname'] == 'Uniprot/SPTREMBL':
                if entry['primary_id'] not in uniprots:
                    if full_entry:
                        uniprots.append(entry)
                    else:
                        uniprots.append(entry['primary_id'])
    return uniprots


if __name__ == '__main__':
    pass
