#!/usr/bin/env python
# -*- coding: utf-8 -*-


"""

This defines the methods that describe/identify binding interfaces.

FÃ¡bio Madeira, 2017+

"""

from __future__ import print_function

import math
import numpy as np

from prointvar.library import vdw_radii
from prointvar.library import vdw_radii_ions
from prointvar.library import hbond_aa_donor
from prointvar.library import hbond_aa_acceptor
from prointvar.library import hbond_other
from prointvar.library import disulfide_aa_donor
from prointvar.library import saltb_donor
from prointvar.library import saltb_acceptor
from prointvar.library import saltb_aa_donor
from prointvar.library import saltb_aa_acceptor
from prointvar.library import aromatic_aa_donor
from prointvar.library import aromatic_aa_acceptor
from prointvar.library import aa_list_ext
from prointvar.library import nc_list
from prointvar.library import metal_ions


# TODO fix the methods here!
def get_distance_between_atoms(data):
    """
    Atomic distance between 3D coordinates.
    
    :param data: pandas DataFrame
    :return: (float) distance
    """

    x1 = data['Cartn_x']
    y1 = data['Cartn_y']
    z1 = data['Cartn_z']
    x2 = data['Cartn_x_2']
    y2 = data['Cartn_y_2']
    z2 = data['Cartn_z_2']
    return round(math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2), 2)


def get_distance_between_atoms_vdw(data, category='label'):
    """
    Atomic plus Van der Waals radii distance between 3D coordinates.
    
    :param data: pandas DataFrame
    :param category: data category to be used as precedence in _atom_site.*_*
        asym_id, seq_id and atom_id
    :return: (float) distance
    """

    if 'distance' not in data:
        data['distance'] = data.apply(get_distance_between_atoms, axis=1)

    atom1 = data['{}_atom_id'.format(category)]
    atom2 = data['{}_atom_id_2'.format(category)]
    elem1 = data['type_symbol']
    elem2 = data['type_symbol_2']
    distance = data['distance']

    vdw1 = get_van_der_waals_radii(atom1, elem1)
    vdw2 = get_van_der_waals_radii(atom2, elem2)
    distance_vdw = round(distance - (vdw1 + vdw2), 2)
    if distance_vdw < 0.0:
        distance_vdw = 0.0

    return distance_vdw


def get_van_der_waals_radii(atom, element):
    """
    Gets Van der Waals (VDW) radii for each atom.

    :param atom: (str) '*_atom_id'
    :param element: (str) 'type_symbol'
    :return: returns VDW radius for that atom.
    """

    # TODO improve the method and tables
    # remove numbers from the atom id (e.g. 'N6' -> 'N')
    new_atom = filter(lambda x: x.isalpha(), atom)
    if atom in vdw_radii:
        vdw = vdw_radii[atom]
    elif atom in vdw_radii_ions and element in metal_ions:
        vdw = vdw_radii_ions[atom]
    elif new_atom in vdw_radii:
        vdw = vdw_radii[new_atom]
    else:
        # based on an average of radii, approximately the same as carbon
        # PMID:10388571
        vdw = 1.70
    return vdw


def get_interaction_chains(data, category='label'):
    """
    Gets information about a particular interaction. Works only from a 
    contact table generated by the methods implemented in the mmcif.py module.
    
    :param data: pandas DataFrame
    :param category: data category to be used as precedence in _atom_site.*_*
        asym_id, seq_id and atom_id
    :return: (str) interaction mode
    """

    chain1 = data['{}_asym_id'.format(category)]
    chain2 = data['{}_asym_id_2'.format(category)]
    if chain1 == chain2:
        int_class = 'Intra-Chain'
    else:
        int_class = 'Inter-Chain'
    return int_class


def get_interaction_topologies(data, category='label'):
    """
    Gets information about a particular interaction. Works only from a 
    contact table generated by the methods implemented in the mmcif.py module.
    
    :param data: pandas DataFrame
    :param category: data category to be used as precedence in _atom_site.*_*
        asym_id, seq_id and atom_id
    :return: (str) topology class
    """

    domain_pfam = ['Pfam_dbAccessionId', 'Pfam_regionId',
                   'Pfam_dbAccessionId_2', 'Pfam_regionId_2']
    domain_cath = ['CATH_dbAccessionId', 'CATH_regionId',
                   'CATH_dbAccessionId_2', 'CATH_regionId_2']
    int_top = "-"
    # if all the pfam columns are available

    chain1 = data['{}_asym_id'.format(category)]
    chain2 = data['{}_asym_id_2'.format(category)]

    if domain_pfam == [k for k in domain_pfam if k in data]:
        if (data['Pfam_dbAccessionId'] == '-' and
                    data['Pfam_dbAccessionId_2'] == '-'):
            int_top = "Other-Other"
        elif (data['Pfam_dbAccessionId'] == '-' or
                    data['Pfam_dbAccessionId_2'] == '-'):
            # one of the two needs to be == '-'
            if data['Pfam_dbAccessionId'] != '-':
                int_top = "Domain-Other"
            elif data['Pfam_dbAccessionId_2'] != '-':
                int_top = "Other-Domain"
        else:
            # both != '-'
            if data['Pfam_dbAccessionId'] != data['Pfam_dbAccessionId_2']:
                int_top = "Domain-Domain"
            elif ((data['Pfam_dbAccessionId'] == data['Pfam_dbAccessionId_2']) and
                    (data['Pfam_regionId'] != data['Pfam_regionId_2'])):
                int_top = "Domain-Domain"
            elif ((data['Pfam_dbAccessionId'] == data['Pfam_dbAccessionId_2']) and
                    (data['Pfam_regionId'] == data['Pfam_regionId_2'])):
                if chain1 == chain2:
                    int_top = "Self"
                else:
                    int_top = "Domain-Domain"
    # if all the cath columns are available
    elif domain_cath == [k for k in domain_cath if k in data]:
        if (data['CATH_dbAccessionId'] == '-' and
                    data['CATH_dbAccessionId_2'] == '-'):
            int_top = "Other-Other"
        elif (data['CATH_dbAccessionId'] == '-' or
                    data['CATH_dbAccessionId_2'] == '-'):
            # one of the two needs to be == '-'
            if data['CATH_dbAccessionId'] != '-':
                int_top = "Domain-Other"
            elif data['CATH_dbAccessionId_2'] != '-':
                int_top = "Other-Domain"
        else:
            # both != '-'
            if data['CATH_dbAccessionId'] != data['CATH_dbAccessionId_2']:
                int_top = "Domain-Domain"
            elif ((data['CATH_dbAccessionId'] == data['CATH_dbAccessionId_2']) and
                    (data['CATH_regionId'] != data['CATH_regionId_2'])):
                int_top = "Domain-Domain"
            elif ((data['CATH_dbAccessionId'] == data['CATH_dbAccessionId_2']) and
                    (data['CATH_regionId'] == data['CATH_regionId_2'])):
                if chain1 == chain2:
                    int_top = "Self"
                else:
                    int_top = "Domain-Domain"
    return int_top


def get_interaction_molecules(data, category='label'):
    """
    Tries to attribute a type of interaction in terms of molecule types.
    
    :param data: pandas DataFrame
    :param category: data category to be used as precedence in _atom_site.*_*
        asym_id, seq_id and atom_id
    :return: returns a type of interaction
    """

    comp1 = data['{}_comp_id'.format(category)]
    comp2 = data['{}_comp_id_2'.format(category)]
    interaction_mode = get_hetero_atom(comp1, comp2)
    if interaction_mode == "":
        interaction_mode = "Protein-Protein"
    return interaction_mode


def get_interaction_properties(data, category='label'):
    """
    :param data: pandas DataFrame
    :param category: data category to be used as precedence in _atom_site.*_*
        asym_id, seq_id and atom_id
    :return: returns a type of interaction
    """

    if 'distance' not in data:
        data['distance'] = data.apply(get_distance_between_atoms, axis=1)
    distance = data['distance']
    comp1 = data['{}_comp_id'.format(category)]
    comp2 = data['{}_comp_id_2'.format(category)]
    atom1 = data['{}_atom_id'.format(category)]
    atom2 = data['{}_atom_id_2'.format(category)]
    return ', '.join(get_interaction_type(distance, comp1, comp2, atom1, atom2))


def get_interaction_type(distance, res1, res2, atom1="", atom2=""):
    """
    Tries to attribute a type of interaction:
    - Hydrogen bond (distance)
    - Dissulfide bond (distance)
    - Salt bridges (Van der Waals) (distance)
    - Hydrophobic (apolar) interactions (distance)

    :param distance: distance in angstrom
    :param res1: res name
    :param res2: res name
    :return: returns a type of interaction or None ("-")
    """

    # potential list of interactions
    interaction = []
    hetatm = get_hetero_atom(res1, res2)
    hbond = get_hydrogen_bond(distance, res1, res2, atom1, atom2,
                              distance_threshold=4.0, angle_threshold=180,
                              hetatm=hetatm)
    if hbond != "":
        interaction.append(hbond)

    disulb = get_disulfide_bond(distance, res1, res2, atom1, atom2,
                                distance_threshold=3.0, angle_threshold=180)
    if disulb != "":
        interaction.append(disulb)

    saltb = get_salt_bridge(distance, res1, res2, atom1, atom2,
                            distance_threshold=5.0, angle_threshold=180)
    if saltb != "":
        interaction.append(saltb)

    aromatic = get_aromatic_bond(distance, res1, res2, atom1, atom2,
                                 distance_threshold=5.0, angle_threshold=180)
    if aromatic != "":
        interaction.append(aromatic)

    if not interaction:
        interaction = ['Van der Waals']

    return interaction


def get_hydrogen_bond(distance, res1, res2, atom1="", atom2="",
                      distance_threshold=4.0, angle_threshold=180,
                      hetatm=None):
    """
    http://www.ks.uiuc.edu/Research/vmd/plugins/hbonds/
    http://en.wikipedia.org/wiki/Hydrogen_bond
    http://www.csb.yale.edu/userguides/datamanip/hbplus/algorithm.txt
    http://www.csb.yale.edu/userguides/datamanip/hbplus/hbplus_descrip.html

    Hydrogen bonds are recorded based on a geometric criterion:
    1. The distance between acceptor and hydrogen is less than or equal to
       *distance* (default is 3.2 Ã).
    2. The angle between donor-hydrogen-acceptor is greater than or equal to
       *angle* (default is 120Âº). (>90Âº for the angle AA-A. see McDonald&Thornton)


    H bonds with donor-acceptor distances of 2.2-2.5 Ã as âstrong, mostly covalentâ,
    2.5-3.2 Ã as âmoderate, mostly electrostaticâ, 3.2-4.0 Ã as âweak, electrostaticâ

    More info:
        L.M. Gregoret, S.D. Rader, R.J. Fletterick, and
        F.E. Cohen. Hydrogen bonds involving sulfur atoms in proteins. Proteins,
        9(2):99â107, 1991. 10.1002/prot.340090204

        McDonald IK1, Thornton JM. Satisfying hydrogen bonding potential in
        proteins. J Mol Biol. 1994 May 20;238(5):777-93.

    TODO: angles!

    :param distance: distance between residues
    :param res1: Residue 1
    :param res2: Residue 2
    :param distance_threshold: distance threshold
    :param angle_threshold: angle threshold
    :return: Returns *potential* hydrogen bonds
    """

    interaction = ""

    if hetatm != "":
        # direction res1 -> res2 and res2 -> res1
        if atom1 != "" and atom2 != "":
            if distance <= distance_threshold and \
                    ((res1 in hbond_aa_donor and
                              atom1 in hbond_aa_donor[res1] and atom2 in hbond_other) or
                     (res1 in hbond_aa_acceptor and
                              atom1 in hbond_aa_acceptor[res1] and atom2 in hbond_other)):
                interaction = "Hydrogen-Bond"

    else:
        # direction res1 -> res2 and res2 -> res1
        if atom1 == "" and atom2 == "":
            if distance <= distance_threshold and \
                                (res1 in hbond_aa_donor and res2 in hbond_aa_acceptor or
                                 res1 in hbond_aa_acceptor and res2 in hbond_aa_donor):
                interaction = "Hydrogen-Bond"
        else:
            if distance <= distance_threshold and \
                    ((res1 in hbond_aa_donor and res2 in hbond_aa_acceptor and
                              atom1 in hbond_aa_donor[res1] and atom2 in hbond_aa_acceptor[res2]) or
                     (res1 in hbond_aa_acceptor and res2 in hbond_aa_donor and
                              atom1 in hbond_aa_acceptor[res1] and atom2 in hbond_aa_donor[res2])):
                interaction = "Hydrogen-Bond"

    return interaction


def get_disulfide_bond(distance, res1, res2, atom1="", atom2="",
                       distance_threshold=3.0, angle_threshold=180):
    """
    http://en.wikipedia.org/wiki/Disulfide_bond
    http://149.171.101.136/python/disulfideanalysis/

    S-S bonds could be obtained by looking for the CONECT lines in the PDB and
    looking for pairs of interacting CYS residues.

    Instead:
    The disulfide bond is about 2.05 Ã (<6.5Ã) in length, about 0.5 Ã longer than a CâC bond.
    Rotation about the SâS axis is subject to a low barrier. Disulfides show a distinct preference
    for dihedral angles approaching 90Â°. When the angle approaches 0Â° or 180Â°, then the disulfide is
    a significantly better oxidant.

    More info in:
        Schmidt B1, Ho L, Hogg PJ. Allosteric disulfide bonds.
        Biochemistry. 2006 Jun 20;45(24):7429-33.

    TODO: angles!

    :param distance: distance between residues
    :param res1: Residue 1
    :param res2: Residue 2
    :param distance_threshold: distance threshold
    :param angle_threshold: angle threshold
    :return: Returns *potential* disulfide bonds
    """

    interaction = ""
    # direction res1 -> res2 and res2 -> res1
    if atom1 == "" and atom2 == "":
        if distance <= distance_threshold and res1 in disulfide_aa_donor and res2 in disulfide_aa_donor:
            interaction = "Disulfide-Bond"
    else:
        if distance <= distance_threshold and \
                (res1 in disulfide_aa_donor and res2 in disulfide_aa_donor and
                 atom1 in disulfide_aa_donor[res1] and atom2 in disulfide_aa_donor[res2]):
            interaction = "Disulfide-Bond"

    return interaction


def get_salt_bridge(distance, res1, res2, atom1="", atom2="",
                    distance_threshold=5.0, angle_threshold=180):
    """
    http://www.ks.uiuc.edu/Research/vmd/plugins/saltbr/
    http://en.wikipedia.org/wiki/Salt_bridge_(protein_and_supramolecular)

    A salt bridge is considered to be formed if the distance between any of the oxygen
    atoms of acidic residues and the nitrogen atoms of basic residues are within the cut-off
    distance (default 3.2 Angstroms) in at least one frame.

    Salt bridges or (Ionic interactions) occur between acidic [ASP, GLU] and basic [ARG, HIS, LYS, HSP]
    residues.

    In particular, this means that if all the histidine residues have resname HIS (often the case
    in original PDB files), all of them will be considered in the salt bridges calculation.
    On the other hand, if the histidine residues have resnames HSP, HSD, or HSE (as specified
    in the CHARMM force field), only the protonated histidines HSP will be considered in the calculation.

    TODO: angles!

    :param distance: distance between residues
    :param res1: Residue 1
    :param res2: Residue 2
    :param distance_threshold: distance threshold
    :param angle_threshold: angle threshold
    :return: Returns *potential* salt-bridges
    """

    interaction = ""
    # direction res1 -> res2 and res2 -> res1
    if atom1 == "" and atom2 == "":
        if distance <= distance_threshold and \
                                    (res1 in saltb_donor and res2 in saltb_acceptor or
                                     res1 in saltb_acceptor and res2 in saltb_donor):
            interaction = "Salt-Bridge"
    else:
        if distance <= distance_threshold and \
                ((res1 in saltb_donor and res2 in saltb_acceptor and
                          atom1 in saltb_aa_donor[res1] and atom2 in saltb_aa_acceptor[res2]) or
                 (res1 in saltb_acceptor and res2 in saltb_donor and
                          atom1 in saltb_aa_acceptor[res1] and atom2 in saltb_aa_donor[res2])):
            interaction = "Salt-Bridge"

    return interaction


def get_aromatic_bond(distance, res1, res2, atom1="", atom2="",
                      distance_threshold=5.0, angle_threshold=180):
    """
    http://en.wikipedia.org/wiki/Stacking_(chemistry)

    Aromatic-aromatic interactions occur between aromatic residues [Phe, Tyr, Trp, His]

    More info:
        Burley, S., & Petsko, G. (1985).
        Aromatic-aromatic interaction: a mechanism of protein structure stabilization.
        Science, (July), 23â28. Retrieved from http://www.sciencemag.org/content/229/4708/23.short

    TODO: angles!

    :param distance: distance between residues
    :param res1: Residue 2
    :param res2: Residue 1
    :param distance_threshold: distance threshold
    :param angle_threshold: angle threshold
    :return: Returns *potential* salt-bridges
    """

    interaction = ""
    # direction res1 -> res2 and res2 -> res1
    if atom1 == "" and atom2 == "":
        if distance <= distance_threshold and \
                                    (res1 in aromatic_aa_donor and res2 in aromatic_aa_acceptor or
                                     res1 in aromatic_aa_acceptor and res2 in aromatic_aa_donor):
            interaction = "Aromatic-Aromatic"
    else:
        if distance <= distance_threshold and \
                ((res1 in aromatic_aa_donor and res2 in aromatic_aa_acceptor and
                          atom1 in aromatic_aa_donor[res1] and atom2 in aromatic_aa_acceptor[res2]) or
                 (res1 in aromatic_aa_acceptor and res2 in aromatic_aa_donor and
                          atom1 in aromatic_aa_acceptor[res1] and atom2 in aromatic_aa_donor[res2])):
            interaction = "Aromatic-Aromatic"

    return interaction


def get_hetero_atom(res1, res2):
    """
    Simply looks for res_names different from the standard amino acid names.

    :param res1: Residue 2
    :param res2: Residue 1
    :returns: Returns *potential* hetatms
    """

    interaction = ""
    # direction res1 -> res2 and res2 -> res1

    if res1 not in aa_list_ext or res2 not in aa_list_ext:
        interaction = "Protein-Ligand"
    if res1 in nc_list or res2 in nc_list:
        interaction = "Protein-Nucleotide"

    return interaction


def get_vector_scaled(v, factor):
    """
    Scales a vector by the provided factor.

    :param v: vector (list, tuple or np.array)
    :param factor: (float or int)
    :return: scaled vector
    """
    assert hasattr(v, '__iter__')
    return [u * factor for u in v]


def get_vector_subtraction(v1, v2):
    """
    Performs Vector subtraction: vector1 - vector2.

    :param v1: 1st vector (list, tuple or np.array)
    :param v2: 2nd vector (list, tuple or np.array)
    :return: a new vector
    """
    assert hasattr(v1, '__iter__')
    assert hasattr(v2, '__iter__')
    return [u1 - u2 for u1, u2 in zip(v1, v2)]


def get_vectors_from_points(p1, p2, p3):
    """
    Expects a 3D points where each element typically correspond to
    (x, y, z) coordinates.

    :param p1: 3D coordinates for 1st point (list, tuple or np.array)
    :param p2: 3D coordinates for 2nd point (list, tuple or np.array)
    :param p3: 3D coordinates for 3rd point (list, tuple or np.array)
    :return: returns two vectors
    """

    assert hasattr(p1, '__iter__')
    assert hasattr(p2, '__iter__')
    assert hasattr(p3, '__iter__')
    v1 = get_vector_subtraction(p1, p2)
    v2 = get_vector_subtraction(p1, p3)
    return v1, v2


def get_unit_vector(v):
    """
    Returns the unit vector / norm of the vector.
    Ã» = u / ||u||

    Uses: linear algebra Euclidean (Frobenius) normalisation: np.linalg.norm
    :param v: vector (list, tuple or np.array)
    :return: returns the unity vector
    """
    assert hasattr(v, '__iter__')
    return v / np.linalg.norm(v)


def get_angle_between_vectors(v1, v2):
    """
    Returns the angle in radians between vectors 'v1' and 'v2'.
        http://stackoverflow.com/questions/2827393/
            angles-between-two-n-dimensional-vectors-in-python

    Uses: dot product: np.dot
    :param v1: 1st vector (list, tuple or np.array)
    :param v2: 2nd vector (list, tuple or np.array)
    :returns: Returns the angle between the two vectors
    """
    assert hasattr(v1, '__iter__')
    assert hasattr(v2, '__iter__')
    uv1 = get_unit_vector(v1)
    uv2 = get_unit_vector(v2)
    return np.arccos(np.clip(np.dot(uv1, uv2), -1.0, 1.0))


if __name__ == '__main__':
    pass
